// Given the roots of two binary trees, root and subroot, return true if there is a subtree of root with the same structure and the node values of subroot and false otherwise.

public class SubTreeOfAnotherTree {

    static class Node {
        int data;
        Node left;
        Node right;

        Node(int data){
            this.data = data;
            this.left = null;
            this.right = null;
        }
    }

    public static boolean isIdentical(Node node, Node subRoot){
        if(node == null && subRoot == null){
            return true;
        } else if (node == null || subRoot == null || node.data != subRoot.data){
            return false;
        } 
        if(!isIdentical(node.left, subRoot.left)){
            return false;
        }
        if(!isIdentical(node.right, subRoot.right)){
            return false;
        }
        return true;
    }

    public static boolean isSubTree(Node root, Node subRoot){
        if(root == null){
            return false;
        }
        if(root.data == subRoot.data){
            if(isIdentical(root,subRoot)){
                return true;
            }
        }
        boolean leftAns = isSubTree(root.left, subRoot);
        boolean rightAns = isSubTree(root.right, subRoot);

        return leftAns || rightAns;

    }
    public static void main (String args[]){

 /*                     1
                      /  \
                     2    3
                    / \    \
                   4   5    6 
*/
        Node newNode = new Node(1);
        newNode.left = new Node(2);
        newNode.right = new Node(3);
        newNode.left.left = new Node(4);
        newNode.left.right = new Node(5);
        newNode.right.right = new Node(6);

/*                      2
                       / \
                      4   5 
*/                  

        Node subRoot = new Node(2);
        subRoot.left = new Node(4);
        subRoot.right = new Node(5);

        System.out.println("SubTree is present in the tree = "+isSubTree(newNode, subRoot));
    }
}
